## 浏览器缓存

### 什么是浏览器缓存

浏览器将之前请求的静态资源存储到本地硬盘中，这些被存储下来的资源叫做缓存,由 http/1 引入

### 什么时候使用缓存

URL 拼接完毕后，在网络进程中发送请求之前，会查询是否存在缓存资源

### 为什么需要缓存

- 节省冗余的网络传输成本
- 浏览器加载资源的速度得到提升
- 减少服务器不必要的负担

### 缓存缺点

更新问题：浏览器缓存机制可能会导致更新问题，因为浏览器可能会缓存旧版本的网页内容，而不是加载最新的内容。这可能会导致用户看到过时的信息或错误的数据。

安全问题：浏览器缓存机制可能会导致安全问题，因为缓存的数据可能包含敏感信息，例如用户登录凭据。如果缓存的数据被恶意用户访问，可能会导致安全漏洞。

存储问题：浏览器缓存机制可能会导致存储问题，因为缓存的数据可能会占用大量的存储空间。这可能会影响用户的设备性能和响应速度。

兼容性问题：浏览器缓存机制可能会导致兼容性问题，因为不同的浏览器可能会有不同的缓存策略和实现方式。这可能会导致网站在某些浏览器中无法正常工作或显示。

### 缓存策略分类

#### 强缓存

> 强缓存是指浏览器直接从本地缓存中读取资源，而不去请求服务器。浏览器会在第一次请求资源时，根据响应头中的`Cache-Control`或`Expires`字段来判断资源是否需要强缓存。如果需要强缓存，则将资源缓存到本地。下次请求同一资源时，浏览器会直接从本地缓存中读取

`Cache-Control`是`http/1.1`的产物

- 值为`max-age=xxx`的过期时间来实现缓存过期时间，单位为秒
- 值为`private`: 仅浏览器可以缓存
- 值为`public`: 浏览器和代理服务器都可以缓存
- 值为`no-cache`: 不进行强缓存
- 值为`no-store`: 不强缓存，也不协商缓存

`Expires`则是`http/1`的产物，通过设置一个过期时间来实现（基本淘汰了可以不关注）
`Expires`字段的缺陷：

1. 缓存时间不灵活：expires 字段指定的是一个具体的过期时间，如果在这个时间之前有数据更新，客户端也无法获取到最新的数据。

2. 依赖于客户端时间：expires 字段是基于客户端时间的，如果客户端的时间与服务器时间不同步，就会导致缓存失效。

3. 无法通过 HTTP 头部控制缓存：expires 字段只能通过服务器响应头部发送，无法通过 HTTP 头部控制缓存，无法对不同的资源设置不同的缓存时间。

4. 不支持秒级缓存：expires 字段只能设置到秒级别，无法实现更精细的缓存控制。

#### 协商缓存

存协商是指浏览器和服务器之间的一种通信机制，用于确定资源是否需要从服务器重新获取或可以从浏览器缓存中获取
**触发条件**

1. 设置了 cache-control: no-cache 字段
2. 强缓存过期
   总结：得设置了强缓存，但是强缓存失效或者不用的时候会走到协商缓存

响应头字段:
`ETag`: http/1.1 产物，返回资源的唯一标识
`Last-Modified`: http/1 的产物，返回资源上次修改的时间

为什么需要`ETag`:

1. 某些文件会周期性地修改，但是内容不该，不需要仅根据修改时间来判断
2. 某些文件修改频繁，但是检查更新的粒度是秒级的,因此资源的更新不一定准确

请求头字段:

1. ETag -> If-None-Match
2. Last-Modified -> If-Modified-Since

作用过程：

1. 第一次请求资源时，响应头会带回唯一标识和上次修改时间
2. 强缓存失效时，会带上请求头，对应关系如上
3. 服务器资源未修改则返回 304，告诉浏览器可以直接使用缓存
4. 服务器资源修改，返回状态码 200，并返回最新资源
