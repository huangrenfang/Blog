## 微前端

### 介绍

> 微前端的概念是由 ThoughtWorks 在 2016 年提出的，它借鉴了微服务的架构理念，核心在于将一个庞大的前端应用拆分成多个独立灵活的小型应用，每个应用都可以独立开发、独立运行、独立部署，再将这些小型应用融合为一个完整的应用，或者将原本运行已久、没有关联的几个应用融合为一个应用。

微前端特点：

1. 技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权
2. 独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新
3. 增量升级，在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略
4. 独立运行时，每个微应用之间状态隔离，运行时状态不共享

### 实现介绍

#### iframe

iframe 好理解，乍一看确实是最方便且最稳定的实现方案，只需要塞一个子应用`URL`就完事了，设计好`postMessage`的通信格式也就可以实现`主子应用的通信`，且天生满足`JS`及`CSS`的隔离，简直完美.  
但是缺点也是挺大的，博主毕业就职的公司曾经就因为 iframe 而进行了重构。  
比较明显的短板：

1. 相当于重新加载一个页面，性能问题比较明显。（这个问题博主在第一家就职公司就遇到过，以至于后续需要重构替换掉 iframe 方案）
2. DOM 结构不共享，弹窗无法覆盖全局
3. 刷新页面路由状态丢失
4. 天生硬隔离，无法进行资源共享
   这些问题是避不开的，能解决的话确实是一个非常好的方案

#### WebComponent

`WebComponent`方案比较出名的就是京东的开源框架`Micro-App`了, 通过获取远端 HTML String，通过`CustomElement`定义`ShadowDom`的方式，将子应用封装成一个 WebComponent。

#### 主应用加载子应用资源，分区域渲染

基本原理是将子应用的 JS、CSS 等静态资源加载到基座应用渲染，本质上这两个应用都是在同一个页面，只是渲染的区域不同，并通过一些手段防止多个应用之间的冲突.
这就需要自己实现样式隔离、JS 隔离、沙箱等机制，而业界比较出名的阿里开源框架 qiankun，很多的 changelog 都是在修复沙箱相关的内容，由此来看复杂度还是很高的，使用者还是会在这方面容易踩坑

### 业界内容微前端框架

#### single-spa

`single-spa`是业界内较早推出主应用（基座）加载子应用资源，同在一个 DOM 结构下渲染方案的。  
`single-spa`基于监听`url change`去匹配到对应的子应用并渲染， 这个设计现在也是微前端框架的主流，阿里的 qiankun 以及字节的 garfish 也是沿袭了这个设计

`single-spa`的实现也是相对简单一些，核心的设计就是主应用注册子应用相关信息，在匹配到对应的路由变化的时候，主应用触发子应用生命周期钩子；  
对应的子应用需要对外暴露出来钩子函数，并在函数中执行 DOM 挂在及渲染的逻辑。

也就是说主应用仅是负责监听路由变化、触发对应子应用生命周期函数，最终由子应用来实现渲染的逻辑.

**生命周期**

1. bootstrap 这个生命周期函数会在应用第一次挂载前执行一次。
2. mount 子应用将要挂载时
3. unmount 子应用已挂在，将要卸载时.

`singel-spa`的缺点也是挺值得吐槽的

1. 采用`js entry`的形式，也就是说子应用的资源是需要改造的，需要将子应用整个打包成一个 JS 资源  
   这样常见的打包优化基本上都没了，比如：按需加载、首屏资源加载优化、css 独立打包等优化措施。
2. 没有做`样式隔离`，如果是新项目倒是好说，约定对饮的选择器名称还能解决，但是如果接入一个历史项目，那成本就大了
3. 没有做`JS隔离`，切换子应用的时候，window 可能还是被污染的
4. 没有`资源预加载`
5. 应用间的`通信`也没有做

#### qiankun

`qiankun`是蚂蚁金服出品的，基于`single-spa`进行了封装，也是监听`url change`来实现不同子应用的渲染。  
不同的是，它封装了更多的能力,比如 `js 沙箱`、 `css 样式隔离`、`子应用预加载`，这样就很好的解决了`single-spa`的很多问题.

来看一下`qiankun`是如何处理的

1. 采用 html entry 的形式
2. 样式隔离，有两种形式，一种是为子应用容器包裹上一个`shadowdom节点`，通过`shadowdom`实现样式隔离.另外一种就是`css scoped`，更改 CSS 选择器名称来避免全局污染
3. `js沙箱`实现隔离,`qiankun`提供了三种不同场景使用的沙箱
   第一种是**snapshotSandbox(快照沙箱)**
   核心思想是打一个快照，记录下刚激活沙箱时的 window，再维护一个记录沙箱状态下修改的记录。  
   如果存在修改记录，window 将修改的记录添加上。  
   推出时再将沙箱状态下的 Window 修改记录同步即可

快照沙箱是会对 window 进行操作的，是会造成污染的，所以他是浏览器不支持 proxy 下的降级策略

第二种是**proxySandbox(代理沙箱)**  
`proxySandbox`采用了 ES6 的 proxy 代理，在沙箱内部维护了 fakewindow，读写操作优先使用 fakewindow，这样就不会造成污染了。

因为`legacySandbox(单例沙箱)`与`快照沙箱`实现类似，且都有污染，就不展开说了

4. 资源预加载, 两种实现思路  
   第一种是微前端应用 start 函数执行完毕后预加载所有子应用  
   第二种利用 singe-spa 提供的事件，在第一个应用挂在时预加载所有子应用

5. 应用间通信
   **第一种**  
   qiankun 内部实现一`套观察者模式`，子应用可注册观察者函数，监听函数变化从而实现通信  
   qiankun 内部提供了 `initGlobalState` 方法用于注册 `MicroAppStateActions` 实例用于通信，该实例有三个方法，分别是：  
   `setGlobalState`：设置 `globalState` - 设置新的值时，内部将执行 浅检查，如果检查到 `globalState` 发生改变则触发通知，通知到所有的 观察者 函数。  
   `onGlobalStateChange`：注册 观察者 函数 - 响应 `globalState` 变化，在 `globalState` 发生改变时触发该 观察者 函数。  
   `offGlobalStateChange`：取消 观察者 函数 - 该实例不再响应 globalState 变化。

**第二种**  
通过状态管理工具, 把主应用当做父组件，子应用当做子组件。维护一个 shared 类，在类里实现通信，shared 当做 props 传入到子应用中去使用。

**关于依赖复用的问题**  
这个 issue 就讲得很好，所以就不展开赘述了  
https://github.com/umijs/qiankun/issues/627

#### micro-app

`micro-app`是京东出品的基于 WebComponent 的微前端框架
`micro-app`并没有沿袭`single-spa`的思路，而是借鉴了`WebComponent`的思想，通过`CustomElement`结合自定义的`ShadowDom`，将微前端封装成一个`类WebComponent组件`，从而实现微前端的组件化渲染。并且由于自定义`ShadowDom`的隔离特性，`micro-app`不需要像`single-spa`和`qiankun`一样要求子应用修改渲染逻辑并暴露出方法，也不需要修改 webpack 配置，是目前市面上接入微前端成本最低的方案

一些`JS隔离`、`样式隔离`、`应用间通信`等机制基本上实现的思路都是差不多的  
但是配置上来看的话还要简洁以下，也不需要子应用导出生命周期函数

#### garfish

仅从使用角度和一些机制实现的角度上看，你可以当做是 qiankun 的翻版, 基本上大差不差...
